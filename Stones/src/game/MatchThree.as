package game {	import com.greensock.TweenLite;	import flash.display.*;	import flash.events.*;	import flash.text.*;	import flash.utils.Timer;	import flash.utils.setTimeout;	import flash.utils.clearTimeout;	import flash.utils.setInterval;	import flash.utils.clearInterval;		import game.gems.BaseGem;	import main.Main;		import game.utils.FloatingPopUps;	import game.events.GameEvent;	import game.Specials;		public class MatchThree extends MovieClip 	{		// constants		public const numPieces:uint = 5;//		public const spacing:Number = 60;		public const offsetX:Number = 65;		public const offsetY:Number = 65;				// game grid and mode		private var grid:Array;		public var gameSprite:Sprite;		private var gridSprite:Sprite;		private var firstPiece:BaseGem;		private var isDropping:Boolean;		private var isSwapping:Boolean;		private var gameScore:int;		private var rows:int = 7;		private var columns:int = 7;		//		private var levelTimer:Timer = new Timer(1000);		private var levelTime:int = 300;		private var textTime:TextField = new TextField();		//		private var madeMove:Boolean = false;		//		private var specials:Specials = new Specials();		//		public function MatchThree() 		{					}		// set up grid and start game		public function startMatchThree():void 		{			gridSprite = new Sprite();			addChild(gridSprite);			// create grid array			grid = new Array();			for (var gridrows:int = 0; gridrows < rows; gridrows++) 				grid.push(new Vector.<BaseGem>);			setUpGrid();			isDropping = false;			isSwapping = false;			gameScore = 0;			//levelTimer.start();			textTime.textColor = 0xFFFFFF;			textTime.width = 1000;			textTime.x = 500;			addChild(textTime);			//levelTimer.addEventListener(TimerEvent.TIMER, gameTime);			addEventListener(Event.ENTER_FRAME, movePieces);			//addEventListener(Event.ENTER_FRAME, checkGrid);		}				public function gameTime(event:TimerEvent):void		{			//textTime.text = (levelTime - levelTimer.currentCount).toString();		}				public function useSpecials(event:MouseEvent):void		{			var piece:BaseGem = event.currentTarget as BaseGem;						textTime.text = "";			gameSprite.removeChild(piece);			grid[piece.col][piece.row] = null;			//checkGrid();			affectAbove(piece);			//addNewPieces();						//levelTime += specials.addTime();		}				public function setUpGrid():void 		{			// loop until valid starting grid			while (true) 			{				// create sprite				gameSprite = new Sprite();								// add 64 random pieces				for (var col:int = 0; col < columns; col++) 					for (var row:int = 0; row < rows; row++)						addPiece(col, row);								// try again if matches are present				if (lookForMatches().length != 0) continue;								// try again if no possible moves				if (lookForPossibles() == false) continue;								// no matches, but possibles exist: good board found				break;			} 						// add sprite			addChild(gameSprite);		}				// create a random piece, add to sprite and grid		public function addPiece(col:int, row:int):BaseGem 		{			var newPiece:BaseGem = new BaseGem();			newPiece.init(Math.ceil(Math.random() * numPieces), col, row);			newPiece.x = col * spacing + offsetX;			newPiece.y = row * spacing + offsetY;			newPiece.col = col;			newPiece.row = row;			/*if ((col == 7 && row == 0) || (col == 8 && row == 0) || (col == 9 && row == 0) ||			(col == 0 && row == 2) || (col == 1 && row == 2) || (col == 2 && row == 2) || (col == 3 && row == 2) || (col == 4 && row == 2) ||			(col == 4 && row == 4) || (col == 4 && row == 5) || (col == 4 && row == 6) || (col == 4 && row == 7))				newPiece.type = 7;			else*/				//newPiece.type = Math.ceil(Math.random() * 6);			//if((col == 4 && row == 3))			//	newPiece.health = 2;			//else				newPiece.health = 0;			//newPiece.gotoAndStop(newPiece.type);			//newPiece.select.visible = false;			gameSprite.addChild(newPiece);			grid[col][row] = newPiece;			//newPiece.addEventListener(MouseEvent.MOUSE_UP, useSpecials);			newPiece.addEventListener(MouseEvent.CLICK, clickPiece);			return newPiece;		}				// player clicks on a piece		public function clickPiece(event:MouseEvent):void 		{			var piece:BaseGem = BaseGem(event.currentTarget);						if (piece.type != 7 && piece.health == 0)			{				// first one selected				if (firstPiece == null) 				{					//piece.select.visible = true;					firstPiece = piece;									// clicked on first piece again				} 				else if (firstPiece == piece) 				{					//piece.select.visible = false;					firstPiece = null;					// clicked on second piece				} 				else 				{					//firstPiece.select.visible = false;										// same row, one column over					if ((firstPiece.row == piece.row) && (Math.abs(firstPiece.col - piece.col) == 1)) 					{						makeSwap(firstPiece,piece);						firstPiece = null;											// same column, one row over					} 					else if ((firstPiece.col == piece.col) && (Math.abs(firstPiece.row - piece.row) == 1)) 					{						makeSwap(firstPiece,piece);						firstPiece = null;											// bad move, reassign first piece					} 					else 					{						firstPiece = piece;						//firstPiece.select.visible = true;					}				}			}		}		// start animated swap of two pieces		public function makeSwap(piece1:BaseGem, piece2:BaseGem):void 		{			swapPieces(piece1, piece2);						// check to see if move was fruitful			if (lookForMatches().length == 0) 				swapPieces(piece1, piece2);			else 				isSwapping = true;		}				public function makeNullSwap(col:int, row:int, i:int):void 		{			grid[col + i][row].col = col;			grid[col][row] = grid[col + i][row];			grid[col + i][row] = null;			isSwapping = true;			if (grid[col][row + 1] == null)				startFall(grid[col][row]);		}				// swap two pieces		public function swapPieces(piece1:BaseGem , piece2:BaseGem):void 		{			// swap row and col values			var tempCol:uint = piece1.col;			var tempRow:uint = piece1.row;			piece1.col = piece2.col;			piece1.row = piece2.row;			piece2.col = tempCol;			piece2.row = tempRow;						// swap grid positions			grid[piece1.col][piece1.row] = piece1;			grid[piece2.col][piece2.row] = piece2;					}		// if any pieces are out of place, move them a step closer to being in place		// happens when pieces are swapped, or they are dropping		public function movePieces(event:Event):void 		{				madeMove = false;			for (var col:int = 0; col < columns; col++) 			{				for (var row:int = 0; row < rows; row++) 				{					if (grid[col][row] != null /*&& grid[col][row].type != 7 && grid[col][row].health == 0*/) 					{						//trace(col,  row)						//trace(grid[col][row].y,  grid[col][row].row * spacing + offsetY)						if (grid[col][row].x < grid[col][row].col * spacing + offsetX) 						{							grid[col][row].x += 5;							madeMove = true;						// needs to move left						} 						else if (grid[col][row].x > grid[col][row].col * spacing + offsetX) 						{							grid[col][row].x -= 5;							madeMove = true;						}						// needs to move down						else if (grid[col][row].y < grid[col][row].row * spacing + offsetY) 						{							grid[col][row].y += 5;							madeMove = true;						// needs to move up						} 						else if (grid[col][row].y > grid[col][row].row * spacing + offsetY) 						{							grid[col][row].y -= 5;							madeMove = true;						// needs to move right						} 					}				}			}						/*for (col = 0; col < columns; col++) 			{				for (row = rows - 1; row >= 0; row--) 				{											var i:int = columns / 2 - 1 - col < 0 ? -1 : 1;					if (grid[col][row] == null && grid[col + i][row] != null && grid[col + i][row].health == 0  && grid[col + i + i][row] != null && 						grid[col + i][row].type != 7 && !madeMove && !isSwapping && aboveBlock(col, row))					{						makeNullSwap(col, row, i);						affectNullAbove(col + i, row);						break;					}				}			}*/						// if all dropping is done			if (isDropping && !madeMove)			{				isDropping = false;				findAndRemoveMatches();							// if all swapping is done			} 			else if (isSwapping && !madeMove) 			{				isSwapping = false;				findAndRemoveMatches();			}		}				// gets matches and removes them, applies points				public function findAndRemoveMatches():void 		{			// get list of matches			var matches:Array = lookForMatches();			for (var i:int = 0; i < matches.length; i++) 			{				var numPoints:Number = (matches[i].length - 1) * 50;				for (var j:int = 0; j < matches[i].length; j++) 				{					if (gameSprite.contains(matches[i][j]) && matches[i][j].health == 0) 					{						//var pb:FloatingPopUps = new FloatingPopUps(String(numPoints), matches[i][j]);						//addChild(pb);						addScore(numPoints);						//						gameSprite.removeChild(grid[matches[i][j].col][matches[i][j].row]);						grid[matches[i][j].col][matches[i][j].row] = null;						//(matches[i][j] as BaseGem).addEventListener(GameEvent.GEM_DEATH, onDeathEnd);						//(matches[i][j] as BaseGem).playDeath();						affectAbove(matches[i][j]);					}					if (gameSprite.contains(matches[i][j]) && matches[i][j].health != 0)						grid[matches[i][j].col][matches[i][j].row].health--;				}			}						// add any new piece to top of board			addNewPieces();			//			// no matches found, maybe the game is over?			if (matches.length == 0) 				if (!lookForPossibles()) 					endGame();		}		//		private function onDeathEnd(e:GameEvent):void {			e.params.removeEventListener(GameEvent.GEM_DEATH, onDeathEnd);			gameSprite.removeChild(e.params);			}		//				//return an array of all matches found		public function lookForMatches():Array 		{			var matchList:Array = new Array();						// search for horizontal matches			for (var row:int = 0; row < rows; row++) 			{				for (var col:int = 0; col < columns - 2; col++) 				{					var match:Array = getMatchHoriz(col,row);					if (match.length > 2 && grid[col][row].type != 7) 					{						matchList.push(match);						col += match.length - 1;					}				}			}						// search for vertical matches			for (col = 0; col < columns; col++) 			{				for (row = 0; row < rows - 2; row++) 				{					match = getMatchVert(col,row);					if (match.length > 2 && grid[col][row].type != 7) 					{						matchList.push(match);						row += match.length-1;					}					}			}			//trace("matchList: " + matchList);			return matchList;		}				// look for horizontal matches starting at this point		public function getMatchHoriz(col:int, row:int):Array 		{			var match:Array = new Array(grid[col][row]);			for (var i:int = 1; col + i < columns; i++) 			{				if (grid[col][row] != null && grid[col + i][row] != null && grid[col][row].type == grid[col + i][row].type)					match.push(grid[col + i][row]);				else					return match;			}			return match;		}		// look for vertical matches starting at this point		public function getMatchVert(col:int, row:int):Array 		{			var match:Array = new Array(grid[col][row]);			for (var i:int = 1; row + i < rows; i++) 			{				if (grid[col][row] != null && grid[col][row + i] != null && grid[col][row].type == grid[col][row + i].type)					match.push(grid[col][row+i]);				else 					return match;			}			return match;		}		//		private function checkGrid():void {//e:Event			while (gridSprite.numChildren > 0) {				gridSprite.removeChildAt(0);				}						var size:int = 45;			var cols:int;			var rows:int;			var rect:Sprite;						for (cols = 0; cols < grid.length; cols++ ) {				for (rows = 0; rows < grid[cols].length; rows++ ) {					if (grid[cols][rows] == null) {						rect = new Sprite();						//rect.graphics.lineStyle(2, 0xFF0000);						rect.graphics.beginFill(0xFF0000);						rect.graphics.drawRect(0, 0, size, size);						rect.graphics.endFill();						gridSprite.addChild(rect);						rect.x = cols * size;						rect.y = rows * size;						}else {							rect = new Sprite();							rect.graphics.beginFill(0xFFFF00);							rect.graphics.drawRect(0, 0, size, size);							rect.graphics.endFill();							gridSprite.addChild(rect);							rect.x = cols * size;							rect.y = rows * size;							}					}				}			}				// tell all pieces above this one to move down		public function affectAbove(piece:BaseGem):void 		{			var row:int = piece.row;			while (row >= 0) {				if (grid[piece.col][row] != null) {					grid[piece.col][row].row++;					grid[piece.col][row + 1] = grid[piece.col][row];					grid[piece.col][row] = null;					}				row--;				}		}		public function affectNullAbove(col:int, row:int):void 		{			for (var j:int = row - 1; j >= 0; j--) 			{				if (grid[col][j] != null && (grid[col][j].type == 7 || grid[col][j].health != 0))					break;				if (grid[col][j] != null) 				{					grid[col][j].row++;					grid[col][j + 1] = grid[col][j];					grid[col][j] = null;				}			}		}				public function startFall(piece:BaseGem):void		{			var row:int = piece.row + 1;			while (grid[piece.col][row] == null)			{				grid[piece.col][row - 1].row++;				grid[piece.col][row] = grid[piece.col][row -1];				grid[piece.col][row - 1] = null;				row++;			}		}				// if there are missing pieces in a column, add one to drop		public function addNewPieces():void 		{			for (var col:int = 0; col < columns; col++) 			{				var missingPieces:int = 0;				for (var row:int = rows - 1; row >= 0; row--) 				{					if (grid[col][row] == null && !aboveBlock(col, row)) 					{						var newPiece:BaseGem = addPiece(col, row);						newPiece.y = offsetY - spacing - spacing * missingPieces++;						isDropping = true;					}				}			}		}				public function aboveBlock(col:int, row:int):Boolean 		{			for (var j:int = row; j >= 0; j--) 			{				if (grid[col][j] != null && (grid[col][j].type == 7 || grid[col][j].health == 0))					return true;			}						return false;		}				// look to see if a possible move is on the board		public function lookForPossibles():Boolean 		{						for (var col:int = 0; col < columns; col++) 			{				for (var  row:int = 0; row < rows; row++)				{					if (grid[col][row].type == 7)					return true;					// horizontal possible, two plus one					if (matchPattern(col, row, [[1, 0]], [[ -2, 0], [ -1, -1], [ -1, 1], [2, -1], [2, 1], [3, 0]])) 						return true;					// horizontal possible, middle					if (matchPattern(col, row, [[2, 0]], [[1, -1], [1, 1]])) 						return true;					// vertical possible, two plus one					if (matchPattern(col, row, [[0, 1]], [[0, -2], [ -1, -1], [1, -1], [ -1, 2], [1, 2], [0, 3]])) 						return true;					// vertical possible, middle					if (matchPattern(col, row, [[0, 2]], [[ -1, 1], [1, 1]])) 						return true;				}			}						// no possible moves found			return false;		}		//		//		public function matchPattern(col:int, row:uint, mustHave:Array, needOne:Array):Boolean 		{			var thisType:int = grid[col][row].type;						// make sure this has all must-haves			for (var i:int = 0; i < mustHave.length; i++) 			{				if (!matchType(col + mustHave[i][0], row + mustHave[i][1], thisType)) 					return false;			}						// make sure it has at least one need-ones			for (i = 0; i < needOne.length; i++) 			{				if (matchType(col + needOne[i][0], row + needOne[i][1], thisType)) 					return true;			}			return false;		}				public function matchType(col:int, row:int, type:int):Boolean 		{			// make sure col and row aren't beyond the limit			if ((col < 0) || (col > columns - 1) || (row < 0) || (row > rows - 1)) return false;			return (grid[col][row].type == type);		}				public function addScore(numPoints:int):void 		{			gameScore += numPoints;			Main.getInstance()._gameScore.text = String(gameScore);		}				public function endGame():void 		{			// move to back			setChildIndex(gameSprite,0);			// go to end game			//gotoAndStop("gameover");		}				public function cleanUp():void 		{			grid = null;			removeChild(gameSprite);			gameSprite = null;			removeEventListener(Event.ENTER_FRAME,movePieces);		}	}}