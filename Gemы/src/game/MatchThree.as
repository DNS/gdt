package game {	import flash.display.*;	import flash.events.*;	import flash.text.*;	import flash.utils.Timer;	import flash.utils.setTimeout;	import flash.utils.clearTimeout;	import flash.utils.setInterval;	import flash.utils.clearInterval;		import game.gems.BaseGem;	import main.Main;		public class MatchThree extends MovieClip 	{		// constants		public const numPieces:uint = 5;//		public const spacing:Number = 60;		public const offsetX:Number = 65;		public const offsetY:Number = 65;				// game grid and mode		private var grid:Array;		public var gameSprite:Sprite;		private var gridSprite:Sprite;		private var firstPiece:BaseGem;		private var isDropping:Boolean;		private var isSwapping:Boolean;		private var gameScore:int;		private var rows:int = 8;		private var columns:int = 8;		//		private var levelTimer:Timer = new Timer(1000);		private var levelTime:int = 300;		private var textTime:TextField = new TextField();		//		private var madeMove:Boolean = false;		//		public function MatchThree() 		{					}				public function startMatchThree():void 		{			gridSprite = new Sprite();			addChild(gridSprite);						grid = new Array();			for (var gridrows:int = 0; gridrows < rows; gridrows++) 				grid.push(new Vector.<BaseGem>);			setUpGrid();			isDropping = false;			isSwapping = false;			gameScore = 0;						textTime.textColor = 0xFFFFFF;			textTime.width = 1000;			textTime.x = 500;			addChild(textTime);						addEventListener(Event.ENTER_FRAME, movePieces);					}				public function setUpGrid():void 		{			while (true) 			{				gameSprite = new Sprite();								for (var col:int = 0; col < columns; col++) 					for (var row:int = 0; row < rows; row++)						addPiece(col, row);								if (lookForMatches().length != 0) continue;								if (lookForPossibles() == false) continue;								break;			} 						addChild(gameSprite);		}				public function addPiece(col:int, row:int):BaseGem 		{			var newPiece:BaseGem = new BaseGem();			newPiece.init(Math.ceil(Math.random() * numPieces), col, row);			newPiece.x = col * spacing + offsetX;			newPiece.y = row * spacing + offsetY;			newPiece.col = col;			newPiece.row = row;						gameSprite.addChild(newPiece);			grid[col][row] = newPiece;			newPiece.addEventListener(MouseEvent.CLICK, clickPiece);			return newPiece;		}				public function clickPiece(event:MouseEvent):void 		{			var piece:BaseGem = BaseGem(event.currentTarget);							if (firstPiece == null) 				{					firstPiece = piece;					firstPiece.select(true);				} 				else if (firstPiece == piece) 				{					firstPiece.select();					firstPiece = null;				} 				else 				{					if ((firstPiece.row == piece.row) && (Math.abs(firstPiece.col - piece.col) == 1)) 					{						makeSwap(firstPiece,piece);						firstPiece.select();						firstPiece = null;					} 					else if ((firstPiece.col == piece.col) && (Math.abs(firstPiece.row - piece.row) == 1)) 					{						makeSwap(firstPiece,piece);						firstPiece.select();						firstPiece = null;					} 					else 					{						firstPiece = piece;						firstPiece.select(true);					}				}		}				public function makeSwap(piece1:BaseGem, piece2:BaseGem):void 		{			swapPieces(piece1, piece2);						if (lookForMatches().length == 0) 				swapPieces(piece1, piece2);			else 				isSwapping = true;		}				public function swapPieces(piece1:BaseGem , piece2:BaseGem):void 		{			var tempCol:uint = piece1.col;			var tempRow:uint = piece1.row;			piece1.col = piece2.col;			piece1.row = piece2.row;			piece2.col = tempCol;			piece2.row = tempRow;						grid[piece1.col][piece1.row] = piece1;			grid[piece2.col][piece2.row] = piece2;					}		public function movePieces(event:Event):void 		{				madeMove = false;			for (var col:int = 0; col < columns; col++) 			{				for (var row:int = 0; row < rows; row++) 				{					if (grid[col][row] != null) 					{						if (grid[col][row].x < grid[col][row].col * spacing + offsetX) 						{							grid[col][row].x += 5;							madeMove = true;						} 						else if (grid[col][row].x > grid[col][row].col * spacing + offsetX) 						{							grid[col][row].x -= 5;							madeMove = true;						}												else if (grid[col][row].y < grid[col][row].row * spacing + offsetY) 						{							grid[col][row].y += 5;							madeMove = true;												} 						else if (grid[col][row].y > grid[col][row].row * spacing + offsetY) 						{							grid[col][row].y -= 5;							madeMove = true;												} 					}				}			}						if (isDropping && !madeMove)			{				isDropping = false;				findAndRemoveMatches();							} 			else if (isSwapping && !madeMove) 			{				isSwapping = false;				findAndRemoveMatches();			}		}				public function findAndRemoveMatches():void 		{			var matches:Array = lookForMatches();			for (var i:int = 0; i < matches.length; i++) 			{				var numPoints:Number = (matches[i].length - 1) * 50;				for (var j:int = 0; j < matches[i].length; j++) 				{					if (gameSprite.contains(matches[i][j])) 					{						addScore(numPoints);						//						gameSprite.removeChild(grid[matches[i][j].col][matches[i][j].row]);						grid[matches[i][j].col][matches[i][j].row] = null;						affectAbove(matches[i][j]);					}				}			}						addNewPieces();			//			if (matches.length == 0) 				if (!lookForPossibles()) 					endGame();		}		//		public function lookForMatches():Array 		{			var matchList:Array = new Array();			for (var row:int = 0; row < rows; row++) 			{				for (var col:int = 0; col < columns; col++) 				{					var match:Array = getMatchHoriz(col,row);					if (match.length > 2 && grid[col][row].type != 7) 					{						matchList.push(match);						break;					}				}			}			for (col = 0; col < columns; col++) 			{				for (row = 0; row < rows; row++) 				{					match = getMatchVert(col,row);					if (match.length > 2 && grid[col][row].type != 7) 					{						matchList.push(match);						break;					}					}			}						for (col = 0; col < columns; col++) 			{				for (row = 0; row < rows; row++) 				{					match = getMatchDiagPositive(col,row);					if (match.length > 2 && grid[col][row].type != 7)					{						matchList.push(match);						break;					}					else					{						match = getMatchDiagOposite(col,row);						if (match.length > 2 && grid[col][row].type != 7)						{							matchList.push(match);							break;						}					}				}			}			return matchList;		}				public function getMatchHoriz(col:int, row:int):Array 		{			var match:Array = new Array(grid[col][row]);			for (var i:int = 1; col + i < columns; i++) 			{				if (grid[col][row] != null && grid[col + i][row] != null && grid[col][row].type == grid[col + i][row].type)					match.push(grid[col + i][row]);				else					return match;			}			return match;		}		public function getMatchVert(col:int, row:int):Array 		{			var match:Array = new Array(grid[col][row]);			for (var i:int = 1; row + i < rows; i++) 			{				if (grid[col][row] != null && grid[col][row + i] != null && grid[col][row].type == grid[col][row + i].type)					match.push(grid[col][row+i]);				else 					return match;			}			return match;		}		//		public function getMatchDiagPositive(col:int, row:int):Array 		{			var match:Array = new Array(grid[col][row]);			for (var i:int = 1; row + i < rows; i++) 			{				if(col + i < columns){					if (grid[col][row] != null && grid[col + i][row + i] != null && grid[col][row].type == grid[col + i][row + i].type)						match.push(grid[col+i][row+i]);					else 						return match;				}				else					break;			}			return match;		}				public function getMatchDiagOposite(col:int, row:int):Array 		{			var match:Array = new Array(grid[col][row]);			for (var i:int = 1; row + i < rows; i++) 			{				if(col - i >= 0){					if (grid[col][row] != null && grid[col - i][row + i] != null && grid[col][row].type == grid[col - i][row + i].type)						match.push(grid[col-i][row+i]);					else 						return match;				}				else					break;			}			return match;		}		//		private function checkGrid():void {			while (gridSprite.numChildren > 0) {				gridSprite.removeChildAt(0);				}						var size:int = 45;			var cols:int;			var rows:int;			var rect:Sprite;						for (cols = 0; cols < grid.length; cols++ ) {				for (rows = 0; rows < grid[cols].length; rows++ ) {					if (grid[cols][rows] == null) {						rect = new Sprite();						//rect.graphics.lineStyle(2, 0xFF0000);						rect.graphics.beginFill(0xFF0000);						rect.graphics.drawRect(0, 0, size, size);						rect.graphics.endFill();						gridSprite.addChild(rect);						rect.x = cols * size;						rect.y = rows * size;						}else {							rect = new Sprite();							rect.graphics.beginFill(0xFFFF00);							rect.graphics.drawRect(0, 0, size, size);							rect.graphics.endFill();							gridSprite.addChild(rect);							rect.x = cols * size;							rect.y = rows * size;							}					}				}			}				public function affectAbove(piece:BaseGem):void 		{			var row:int = piece.row;			while (row >= 0) {				if (grid[piece.col][row] != null) {					grid[piece.col][row].row++;					grid[piece.col][row + 1] = grid[piece.col][row];					grid[piece.col][row] = null;					}				row--;				}		}				public function startFall(piece:BaseGem):void		{			var row:int = piece.row + 1;			while (grid[piece.col][row] == null)			{				grid[piece.col][row - 1].row++;				grid[piece.col][row] = grid[piece.col][row -1];				grid[piece.col][row - 1] = null;				row++;			}		}				public function addNewPieces():void 		{			for (var col:int = 0; col < columns; col++) 			{				var missingPieces:int = 0;				for (var row:int = rows - 1; row >= 0; row--) 				{					if (grid[col][row] == null) 					{						var newPiece:BaseGem = addPiece(col, row);						newPiece.y = offsetY - spacing - spacing * missingPieces++;						isDropping = true;					}				}			}		}				public function lookForPossibles():Boolean 		{						for (var col:int = 0; col < columns; col++) 			{				for (var  row:int = 0; row < rows; row++)				{					if (grid[col][row].type == 7)					return true;					if (matchPattern(col, row, [[1, 0]], [[ -2, 0], [ -1, -1], [ -1, 1], [2, -1], [2, 1], [3, 0]])) 						return true;					if (matchPattern(col, row, [[2, 0]], [[1, -1], [1, 1]])) 						return true;					if (matchPattern(col, row, [[0, 1]], [[0, -2], [ -1, -1], [1, -1], [ -1, 2], [1, 2], [0, 3]])) 						return true;					if (matchPattern(col, row, [[0, 2]], [[ -1, 1], [1, 1]])) 						return true;				}			}			return false;		}		//		//		public function matchPattern(col:int, row:uint, mustHave:Array, needOne:Array):Boolean 		{			var thisType:int = grid[col][row].type;			for (var i:int = 0; i < mustHave.length; i++) 			{				if (!matchType(col + mustHave[i][0], row + mustHave[i][1], thisType)) 					return false;			}			for (i = 0; i < needOne.length; i++) 			{				if (matchType(col + needOne[i][0], row + needOne[i][1], thisType)) 					return true;			}			return false;		}				public function matchType(col:int, row:int, type:int):Boolean 		{			if ((col < 0) || (col > columns - 1) || (row < 0) || (row > rows - 1)) return false;			return (grid[col][row].type == type);		}				public function addScore(numPoints:int):void 		{			gameScore += numPoints;			Main.getInstance()._gameScore.text = String(gameScore);		}				public function endGame():void 		{			setChildIndex(gameSprite,0);		}				public function cleanUp():void 		{			grid = null;			removeChild(gameSprite);			gameSprite = null;			removeEventListener(Event.ENTER_FRAME,movePieces);		}	}}