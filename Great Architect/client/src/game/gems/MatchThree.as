package game.gems {	import com.greensock.easing.Linear;	import flash.display.*;	import flash.events.*;	import flash.text.*;	import flash.utils.Timer;	import com.greensock.TweenMax;	import com.greensock.easing.Back;		public class MatchThree extends Sprite 	{		// constants		public const numPieces:uint = 5;		public const spacing:Number = 60;		public const offsetX:Number = 0;		public const offsetY:Number = 0;				// game grid and mode		private var grid:Array;		public var gameSprite:Sprite;		private var firstPiece:BaseGem;		private var rows:int = 12;		private var columns:int = 8;		//		private var isFalling:Boolean = false;		//		public function MatchThree() {			addEventListener(Event.ADDED_TO_STAGE, init);		}		//		private function init(e:Event):void {			removeEventListener(Event.ADDED_TO_STAGE, init);			//			stage.align = StageAlign.TOP_LEFT;			stage.scaleMode = StageScaleMode.NO_SCALE;		}				public function startMatchThree():void 		{			grid = new Array();			for (var gridrows:int = 0; gridrows < rows; gridrows++) 				grid.push(new Vector.<BaseGem>);			setUpGrid();		}				private function setUpGrid():void 		{			while (true) 			{				gameSprite = new Sprite();								for (var col:int = 0; col < columns; col++) 					for (var row:int = 0; row < rows; row++)						addPiece(col, row);								if (lookForMatches().length != 0) continue;								if (lookForPossibles() == false) continue;								break;			} 						addChild(gameSprite);		}				private function addPiece(col:int, row:int):BaseGem 		{			var newPiece:BaseGem = new BaseGem();			newPiece.init(Math.ceil(Math.random() * numPieces), col, row);			if (row == 4)				newPiece.chained();			newPiece.x = col * spacing + offsetX;			newPiece.y = row * spacing + offsetY;			newPiece.col = col;			newPiece.row = row;						gameSprite.addChild(newPiece);			grid[col][row] = newPiece;			newPiece.addEventListener(MouseEvent.CLICK, clickPiece);			return newPiece;		}				private function clickPiece(event:MouseEvent):void 		{			var piece:BaseGem = BaseGem(event.currentTarget);						if (piece.isLocked || piece.isWall || isFalling)				return;						if (firstPiece == null) 			{				firstPiece = piece;				firstPiece.select(true);			} 			else if (firstPiece == piece) 			{				firstPiece.select();				firstPiece = null;			} 			else 			{				if (((firstPiece.row == piece.row) && (Math.abs(firstPiece.col - piece.col) == 1)) ||				((firstPiece.col == piece.col) && (Math.abs(firstPiece.row - piece.row) == 1))) 				{					makeSwap(firstPiece, piece);					firstPiece.select();					firstPiece = null;				}  				else 				{					firstPiece.select();					firstPiece = null;					firstPiece = piece;					firstPiece.select(true);				}			}		}				private function makeSwap(piece1:BaseGem, piece2:BaseGem):void 		{			swapPieces(piece1, piece2);						if (lookForMatches().length == 0) 			{				swapPieces(piece1, piece2);				errorSwapping(piece1, piece2);			}			else				swapping(piece1, piece2);		}				private function swapPieces(piece1:BaseGem, piece2:BaseGem):void 		{			var tempCol:uint = piece1.col;			var tempRow:uint = piece1.row;			piece1.col = piece2.col;			piece1.row = piece2.row;			piece2.col = tempCol;			piece2.row = tempRow;						grid[piece1.col][piece1.row] = piece1;			grid[piece2.col][piece2.row] = piece2;					}				private function swapping(piece1:BaseGem, piece2:BaseGem):void 		{			TweenMax.to(piece1, 0.3, { x:piece1.col * spacing + offsetX, y:piece1.row * spacing + offsetY, onComplete:findAndRemoveMatches } );			TweenMax.to(piece2, 0.3, { x:piece2.col * spacing + offsetX, y:piece2.row * spacing + offsetY } );		}				private function errorSwapping(piece1:BaseGem, piece2:BaseGem):void 		{			TweenMax.to(piece1, 0.3, { x:piece2.col * spacing + offsetX, y:piece2.row * spacing + offsetY, onComplete:piece1Back, onCompleteParams:[piece1], ease:Linear.easeIn } );			TweenMax.to(piece2, 0.3, { x:piece1.col * spacing + offsetX, y:piece1.row * spacing + offsetY, onComplete:piece2Back, onCompleteParams:[piece2], ease:Linear.easeIn } );		}				private function piece1Back(piece:BaseGem):void 		{			TweenMax.to(piece, 0.3, { x:piece.col * spacing + offsetX, y:piece.row * spacing + offsetY, ease:Linear.easeOut } );		}				private function piece2Back(piece:BaseGem):void 		{			TweenMax.to(piece, 0.3, { x:piece.col * spacing + offsetX, y:piece.row * spacing + offsetY, ease:Linear.easeOut } );		}				private function findAndRemoveMatches():void 		{			var matches:Array = lookForMatches();			if (matches.length == 0)			{				isFalling = false;				if (!lookForPossibles()) 					endGame();									return;			}						for (var i:int = 0; i < matches.length; i++) 			{				for (var j:int = 0; j < matches[i].length; j++) 				{					if (gameSprite.contains(matches[i][j]))					{						if (grid[matches[i][j].col][matches[i][j].row].isLocked)						{							grid[matches[i][j].col][matches[i][j].row].unchained();						}						else						{							isFalling = true;							TweenMax.to(grid[matches[i][j].col][matches[i][j].row], 0.5, { blurFilter: { blurX:20, blurY:20, quality:2 }, onComplete:deletePiece, onCompleteParams:[matches[i][j]] } );						}					}				}			}		}		//		private function deletePiece(piece:BaseGem):void 		{			gameSprite.removeChild(piece);			grid[piece.col][piece.row] = null;			affectAbove(piece);		}		//		private function lookForMatches():Array 		{			var matchList:Array = new Array();			for (var row:int = 0; row < rows; row++) 			{				for (var col:int = 0; col < columns; col++) 				{					var match:Array = getMatchHoriz(col, row);					if (match.length > 2) 					{						matchList.push(match);						break;					}				}			}			for (col = 0; col < columns; col++) 			{				for (row = 0; row < rows; row++) 				{					match = getMatchVert(col, row);					if (match.length > 2) 					{						matchList.push(match);						break;					}					}			}						return matchList;		}				private function getMatchHoriz(col:int, row:int):Array 		{			var match:Array = new Array(grid[col][row]);			for (var i:int = 1; col + i < columns; i++) 			{				if (grid[col][row] != null && grid[col + i][row] != null && grid[col][row].type == grid[col + i][row].type)					match.push(grid[col + i][row]);				else					return match;			}			return match;		}		private function getMatchVert(col:int, row:int):Array 		{			var match:Array = new Array(grid[col][row]);			for (var i:int = 1; row + i < rows; i++) 			{				if (grid[col][row] != null && grid[col][row + i] != null && grid[col][row].type == grid[col][row + i].type)					match.push(grid[col][row + i]);				else 					return match;			}			return match;		}				private function affectAbove(piece:BaseGem):void 		{			var row:int = piece.row - 1;			while (row >= 0) {				if (grid[piece.col][row] != null && !grid[piece.col][row].isLocked && !grid[piece.col][row].isWall)				{					(grid[piece.col][row] as BaseGem).row++;					grid[piece.col][row + 1] = grid[piece.col][row];					grid[piece.col][row] = null;					TweenMax.to(grid[piece.col][row + 1], 0.5, { x:(grid[piece.col][row + 1] as BaseGem).col * spacing + offsetX, y:(grid[piece.col][row + 1] as BaseGem).row * spacing + offsetY } );									row--;				}				else					break;			}						addNewPiece(piece.col, row + 1);		}				private function addNewPiece(col:int, index:int):void 		{				if (index == 0) 			{				var newPiece:BaseGem = addPiece(col, index);				newPiece.y = -spacing * (rows - index);				TweenMax.to(newPiece, (index + 1) / 2, { x:newPiece.col * spacing + offsetX, y:newPiece.row * spacing + offsetY, onComplete:findAndRemoveMatches } );			}			else				findAndRemoveMatches();		}				private function lookForPossibles():Boolean 		{			for (var col:int = 0; col < columns; col++) 			{				for (var  row:int = 0; row < rows; row++)				{					if (grid[col][row].type == 7)					return true;					if (matchPattern(col, row, [[1, 0]], [[ -2, 0], [ -1, -1], [ -1, 1], [2, -1], [2, 1], [3, 0]])) 						return true;					if (matchPattern(col, row, [[2, 0]], [[1, -1], [1, 1]])) 						return true;					if (matchPattern(col, row, [[0, 1]], [[0, -2], [ -1, -1], [1, -1], [ -1, 2], [1, 2], [0, 3]])) 						return true;					if (matchPattern(col, row, [[0, 2]], [[ -1, 1], [1, 1]])) 						return true;				}			}			return false;		}		//		//		private function matchPattern(col:int, row:uint, mustHave:Array, needOne:Array):Boolean 		{			var thisType:int = grid[col][row].type;			for (var i:int = 0; i < mustHave.length; i++) 			{				if (!matchType(col + mustHave[i][0], row + mustHave[i][1], thisType)) 					return false;			}			for (i = 0; i < needOne.length; i++) 			{				if (matchType(col + needOne[i][0], row + needOne[i][1], thisType)) 					return true;			}			return false;		}				private function matchType(col:int, row:int, type:int):Boolean 		{			if ((col < 0) || (col > columns - 1) || (row < 0) || (row > rows - 1)) return false;			return (grid[col][row].type == type);		}				private function endGame():void 		{			setChildIndex(gameSprite, 0);		}				private function cleanUp():void 		{			grid = null;			removeChild(gameSprite);			gameSprite = null;		}	}}